// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: mistyswap_offramp.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2018-2023 MobileCoin Inc.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

//// Various possible offramp error codes.
//// This should be kept in sync with mistyswap_offramp_api::Error
//// The ORC prefix is needed since enum variants have to be unique across all enums in the file.
public enum MistyswapOfframp_OfframpResultCode: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case orcInvalid // = 0
  case orcOk // = 1
  case orcTooManyOfframps // = 2
  case orcMixinCredentialsJson // = 3
  case orcOfframpAlreadyInProgress // = 4
  case orcMixin // = 5
  case orcInvalidSrcAssetID // = 6
  case orcInvalidDstAssetID // = 7
  case orcOfframpIDNotFound // = 8
  case orcInvalidSrcExpectedAmount // = 9
  case orcInvalidMinDstReceivedAmount // = 10
  case orcInvalidMaxFeeAmountInDstTokens // = 11
  case orcInvalidFeeTokenSwapMultiplier // = 12
  case UNRECOGNIZED(Int)

  public init() {
    self = .orcInvalid
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .orcInvalid
    case 1: self = .orcOk
    case 2: self = .orcTooManyOfframps
    case 3: self = .orcMixinCredentialsJson
    case 4: self = .orcOfframpAlreadyInProgress
    case 5: self = .orcMixin
    case 6: self = .orcInvalidSrcAssetID
    case 7: self = .orcInvalidDstAssetID
    case 8: self = .orcOfframpIDNotFound
    case 9: self = .orcInvalidSrcExpectedAmount
    case 10: self = .orcInvalidMinDstReceivedAmount
    case 11: self = .orcInvalidMaxFeeAmountInDstTokens
    case 12: self = .orcInvalidFeeTokenSwapMultiplier
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .orcInvalid: return 0
    case .orcOk: return 1
    case .orcTooManyOfframps: return 2
    case .orcMixinCredentialsJson: return 3
    case .orcOfframpAlreadyInProgress: return 4
    case .orcMixin: return 5
    case .orcInvalidSrcAssetID: return 6
    case .orcInvalidDstAssetID: return 7
    case .orcOfframpIDNotFound: return 8
    case .orcInvalidSrcExpectedAmount: return 9
    case .orcInvalidMinDstReceivedAmount: return 10
    case .orcInvalidMaxFeeAmountInDstTokens: return 11
    case .orcInvalidFeeTokenSwapMultiplier: return 12
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension MistyswapOfframp_OfframpResultCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [MistyswapOfframp_OfframpResultCode] = [
    .orcInvalid,
    .orcOk,
    .orcTooManyOfframps,
    .orcMixinCredentialsJson,
    .orcOfframpAlreadyInProgress,
    .orcMixin,
    .orcInvalidSrcAssetID,
    .orcInvalidDstAssetID,
    .orcOfframpIDNotFound,
    .orcInvalidSrcExpectedAmount,
    .orcInvalidMinDstReceivedAmount,
    .orcInvalidMaxFeeAmountInDstTokens,
    .orcInvalidFeeTokenSwapMultiplier,
  ]
}

#endif  // swift(>=4.2)

//// Current offramp state.
//// This should be kept in sync with offramp_impl::OfframpState
//// The OS prefix is needed since enum variants have to be unique across all enums in the file.
public enum MistyswapOfframp_OfframpState: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case osInvalid // = 0
  case osNotStarted // = 1
  case osPolling // = 2
  case osWaiting // = 3
  case osInvalidWithdrawalAddress // = 4
  case osIntermittentError // = 5
  case osBlockedOnSwap // = 6
  case osBlockedOnWithdrawal // = 7
  case osWithdrawalCompleted // = 8
  case osUnrecoverableError // = 9
  case UNRECOGNIZED(Int)

  public init() {
    self = .osInvalid
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .osInvalid
    case 1: self = .osNotStarted
    case 2: self = .osPolling
    case 3: self = .osWaiting
    case 4: self = .osInvalidWithdrawalAddress
    case 5: self = .osIntermittentError
    case 6: self = .osBlockedOnSwap
    case 7: self = .osBlockedOnWithdrawal
    case 8: self = .osWithdrawalCompleted
    case 9: self = .osUnrecoverableError
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .osInvalid: return 0
    case .osNotStarted: return 1
    case .osPolling: return 2
    case .osWaiting: return 3
    case .osInvalidWithdrawalAddress: return 4
    case .osIntermittentError: return 5
    case .osBlockedOnSwap: return 6
    case .osBlockedOnWithdrawal: return 7
    case .osWithdrawalCompleted: return 8
    case .osUnrecoverableError: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension MistyswapOfframp_OfframpState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [MistyswapOfframp_OfframpState] = [
    .osInvalid,
    .osNotStarted,
    .osPolling,
    .osWaiting,
    .osInvalidWithdrawalAddress,
    .osIntermittentError,
    .osBlockedOnSwap,
    .osBlockedOnWithdrawal,
    .osWithdrawalCompleted,
    .osUnrecoverableError,
  ]
}

#endif  // swift(>=4.2)

//// A simplified GRPC-compatible wrapper for Result<_, mistyswap_offramp_api::Error>
public struct MistyswapOfframp_OfframpResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: MistyswapOfframp_OfframpResultCode = .orcInvalid

  public var message: String = String()

  /// For OfframAlreadyInProgress, this is the offramp_id of the existing offramp.
  public var offrampID: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// Offramp parameters.
//// They are separated from the credentials since they are not as sensitive, and it makes it
//// easier to include them to the client in the response to GetOfframpStatus calls.
public struct MistyswapOfframp_OfframpParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The asset being offramped (the token id we will be swapping from). This
  //// would be MOB or eUSD. This is the mixin asset uuid.
  public var srcAssetID: String = String()

  //// The amount we are going to be swapping. We use  strings to allow
  //// decimals.
  public var srcExpectedAmount: String = String()

  //// The Mixin destination asset id (the token id we will be swapping into).
  //// This is the mixin asset uuid.
  public var dstAssetID: String = String()

  //// The token-specific address to withdraw into.
  public var dstAddress: String = String()

  //// The token-specific address tag, if any.
  public var dstAddressTag: String = String()

  //// The minimum amount of destination tokens we expect to receive from
  //// swapping the source tokens. Note that this includes tokens that will
  //// later be swapped for fees if the fee token is not the destination token.
  public var minDstReceivedAmount: String = String()

  //// The maximum amount of destination tokens we are willing to use for fees.
  public var maxFeeAmountInDstTokens: String = String()

  //// A multiplier to be applied to the amount of destination tokens swapped for fee tokens.
  //// This allows controlling how many extra destination tokens are swapped for fee tokens.
  //// Extra tokens are desierable to avoid running into insufficient withdrawal fee issues originating from swap rate fluctuations.
  //// The default is used if this field is set to an empty string.
  //// Setting it to a value lower than 1.0 will result in an error.
  //// The default value is set by the `DEFAULT_FEE_TOKEN_SWAP_MULTIPLIER` constant in the `mistyswap_offramp_impl` crate.
  public var feeTokenSwapMultiplier: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// A request to initiate an offramp.
public struct MistyswapOfframp_InitiateOfframpRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Mixin credentials, as a JSON string.
  public var mixinCredentialsJson: String = String()

  //// Offramp parameters.
  public var params: MistyswapOfframp_OfframpParams {
    get {return _params ?? MistyswapOfframp_OfframpParams()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  public var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  public mutating func clearParams() {self._params = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _params: MistyswapOfframp_OfframpParams? = nil
}

//// A successful response to an InitiateOfframpRequest.
public struct MistyswapOfframp_InitiateOfframpResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Result of the offramp request.
  public var result: MistyswapOfframp_OfframpResult {
    get {return _result ?? MistyswapOfframp_OfframpResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  //// Unique ID derived from the offramp request (set if result code is Ok)
  public var offrampID: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _result: MistyswapOfframp_OfframpResult? = nil
}

//// A request to forget an offramp.
public struct MistyswapOfframp_ForgetOfframpRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Unique ID of the offramp to forget.
  public var offrampID: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// A response to a ForgetOfframpRequest.
public struct MistyswapOfframp_ForgetOfframpResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Result of the offramp request.
  public var result: MistyswapOfframp_OfframpResult {
    get {return _result ?? MistyswapOfframp_OfframpResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _result: MistyswapOfframp_OfframpResult? = nil
}

//// Details about a previously-initiated offramp.
public struct MistyswapOfframp_Offramp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The original offramp parameters.
  public var params: MistyswapOfframp_OfframpParams {
    get {return _storage._params ?? MistyswapOfframp_OfframpParams()}
    set {_uniqueStorage()._params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  public var hasParams: Bool {return _storage._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  public mutating func clearParams() {_uniqueStorage()._params = nil}

  //// Current state of the offramp.
  public var state: MistyswapOfframp_OfframpState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  //// String details, if any, about the current state.
  public var stateDetails: String {
    get {return _storage._stateDetails}
    set {_uniqueStorage()._stateDetails = newValue}
  }

  //// The Mixin withdrawal address as a JSON blob (if available, empty string otherwise)
  public var mixinWithdrawalAddressJson: String {
    get {return _storage._mixinWithdrawalAddressJson}
    set {_uniqueStorage()._mixinWithdrawalAddressJson = newValue}
  }

  //// Ongoing swap info, if any.
  public var ongoingSwap: MistyswapCommon_OngoingSwap {
    get {return _storage._ongoingSwap ?? MistyswapCommon_OngoingSwap()}
    set {_uniqueStorage()._ongoingSwap = newValue}
  }
  /// Returns true if `ongoingSwap` has been explicitly set.
  public var hasOngoingSwap: Bool {return _storage._ongoingSwap != nil}
  /// Clears the value of `ongoingSwap`. Subsequent reads from it will return its default value.
  public mutating func clearOngoingSwap() {_uniqueStorage()._ongoingSwap = nil}

  //// Ongoing withdrawal info, if any. This is a Mixin snapshot JSON blob.
  public var ongoingWithdrawalJson: String {
    get {return _storage._ongoingWithdrawalJson}
    set {_uniqueStorage()._ongoingWithdrawalJson = newValue}
  }

  //// Balances (map of Mixin asset UUID to balance as a decimal number).
  public var balances: Dictionary<String,String> {
    get {return _storage._balances}
    set {_uniqueStorage()._balances = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

//// Get the status of an offramp.
public struct MistyswapOfframp_GetOfframpStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Unique ID of the offramp to get the status of.
  public var offrampID: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// A response to a GetOfframpStatusRequest.
public struct MistyswapOfframp_GetOfframpStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Result of the offramp request.
  public var result: MistyswapOfframp_OfframpResult {
    get {return _result ?? MistyswapOfframp_OfframpResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  //// The offramp status, if the result code is Ok.
  public var offramp: MistyswapOfframp_Offramp {
    get {return _offramp ?? MistyswapOfframp_Offramp()}
    set {_offramp = newValue}
  }
  /// Returns true if `offramp` has been explicitly set.
  public var hasOfframp: Bool {return self._offramp != nil}
  /// Clears the value of `offramp`. Subsequent reads from it will return its default value.
  public mutating func clearOfframp() {self._offramp = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _result: MistyswapOfframp_OfframpResult? = nil
  fileprivate var _offramp: MistyswapOfframp_Offramp? = nil
}

//// Get the state transitions of a given offramp (for debug purposes).
public struct MistyswapOfframp_GetOfframpDebugInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Unique ID of the offramp to get the status of.
  public var offrampID: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

//// A response to a GetOfframpDebugInfoRequest.
public struct MistyswapOfframp_GetOfframpDebugInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Result of the offramp request.
  public var result: MistyswapOfframp_OfframpResult {
    get {return _result ?? MistyswapOfframp_OfframpResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  //// Debug info, encoded as a JSON blob.
  //// The schema is defined by the OfframpDebugInfo Rust struct and serialized by serde.
  public var debugInfoJson: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _result: MistyswapOfframp_OfframpResult? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension MistyswapOfframp_OfframpResultCode: @unchecked Sendable {}
extension MistyswapOfframp_OfframpState: @unchecked Sendable {}
extension MistyswapOfframp_OfframpResult: @unchecked Sendable {}
extension MistyswapOfframp_OfframpParams: @unchecked Sendable {}
extension MistyswapOfframp_InitiateOfframpRequest: @unchecked Sendable {}
extension MistyswapOfframp_InitiateOfframpResponse: @unchecked Sendable {}
extension MistyswapOfframp_ForgetOfframpRequest: @unchecked Sendable {}
extension MistyswapOfframp_ForgetOfframpResponse: @unchecked Sendable {}
extension MistyswapOfframp_Offramp: @unchecked Sendable {}
extension MistyswapOfframp_GetOfframpStatusRequest: @unchecked Sendable {}
extension MistyswapOfframp_GetOfframpStatusResponse: @unchecked Sendable {}
extension MistyswapOfframp_GetOfframpDebugInfoRequest: @unchecked Sendable {}
extension MistyswapOfframp_GetOfframpDebugInfoResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "mistyswap_offramp"

extension MistyswapOfframp_OfframpResultCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ORC_INVALID"),
    1: .same(proto: "ORC_OK"),
    2: .same(proto: "ORC_TOO_MANY_OFFRAMPS"),
    3: .same(proto: "ORC_MIXIN_CREDENTIALS_JSON"),
    4: .same(proto: "ORC_OFFRAMP_ALREADY_IN_PROGRESS"),
    5: .same(proto: "ORC_MIXIN"),
    6: .same(proto: "ORC_INVALID_SRC_ASSET_ID"),
    7: .same(proto: "ORC_INVALID_DST_ASSET_ID"),
    8: .same(proto: "ORC_OFFRAMP_ID_NOT_FOUND"),
    9: .same(proto: "ORC_INVALID_SRC_EXPECTED_AMOUNT"),
    10: .same(proto: "ORC_INVALID_MIN_DST_RECEIVED_AMOUNT"),
    11: .same(proto: "ORC_INVALID_MAX_FEE_AMOUNT_IN_DST_TOKENS"),
    12: .same(proto: "ORC_INVALID_FEE_TOKEN_SWAP_MULTIPLIER"),
  ]
}

extension MistyswapOfframp_OfframpState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OS_INVALID"),
    1: .same(proto: "OS_NOT_STARTED"),
    2: .same(proto: "OS_POLLING"),
    3: .same(proto: "OS_WAITING"),
    4: .same(proto: "OS_INVALID_WITHDRAWAL_ADDRESS"),
    5: .same(proto: "OS_INTERMITTENT_ERROR"),
    6: .same(proto: "OS_BLOCKED_ON_SWAP"),
    7: .same(proto: "OS_BLOCKED_ON_WITHDRAWAL"),
    8: .same(proto: "OS_WITHDRAWAL_COMPLETED"),
    9: .same(proto: "OS_UNRECOVERABLE_ERROR"),
  ]
}

extension MistyswapOfframp_OfframpResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OfframpResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .standard(proto: "offramp_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.offrampID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .orcInvalid {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.offrampID.isEmpty {
      try visitor.visitSingularBytesField(value: self.offrampID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MistyswapOfframp_OfframpResult, rhs: MistyswapOfframp_OfframpResult) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.offrampID != rhs.offrampID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MistyswapOfframp_OfframpParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OfframpParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "src_asset_id"),
    2: .standard(proto: "src_expected_amount"),
    3: .standard(proto: "dst_asset_id"),
    4: .standard(proto: "dst_address"),
    5: .standard(proto: "dst_address_tag"),
    6: .standard(proto: "min_dst_received_amount"),
    7: .standard(proto: "max_fee_amount_in_dst_tokens"),
    8: .standard(proto: "fee_token_swap_multiplier"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.srcAssetID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.srcExpectedAmount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.dstAssetID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.dstAddress) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.dstAddressTag) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.minDstReceivedAmount) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.maxFeeAmountInDstTokens) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.feeTokenSwapMultiplier) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.srcAssetID.isEmpty {
      try visitor.visitSingularStringField(value: self.srcAssetID, fieldNumber: 1)
    }
    if !self.srcExpectedAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.srcExpectedAmount, fieldNumber: 2)
    }
    if !self.dstAssetID.isEmpty {
      try visitor.visitSingularStringField(value: self.dstAssetID, fieldNumber: 3)
    }
    if !self.dstAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.dstAddress, fieldNumber: 4)
    }
    if !self.dstAddressTag.isEmpty {
      try visitor.visitSingularStringField(value: self.dstAddressTag, fieldNumber: 5)
    }
    if !self.minDstReceivedAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.minDstReceivedAmount, fieldNumber: 6)
    }
    if !self.maxFeeAmountInDstTokens.isEmpty {
      try visitor.visitSingularStringField(value: self.maxFeeAmountInDstTokens, fieldNumber: 7)
    }
    if !self.feeTokenSwapMultiplier.isEmpty {
      try visitor.visitSingularStringField(value: self.feeTokenSwapMultiplier, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MistyswapOfframp_OfframpParams, rhs: MistyswapOfframp_OfframpParams) -> Bool {
    if lhs.srcAssetID != rhs.srcAssetID {return false}
    if lhs.srcExpectedAmount != rhs.srcExpectedAmount {return false}
    if lhs.dstAssetID != rhs.dstAssetID {return false}
    if lhs.dstAddress != rhs.dstAddress {return false}
    if lhs.dstAddressTag != rhs.dstAddressTag {return false}
    if lhs.minDstReceivedAmount != rhs.minDstReceivedAmount {return false}
    if lhs.maxFeeAmountInDstTokens != rhs.maxFeeAmountInDstTokens {return false}
    if lhs.feeTokenSwapMultiplier != rhs.feeTokenSwapMultiplier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MistyswapOfframp_InitiateOfframpRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InitiateOfframpRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mixin_credentials_json"),
    2: .same(proto: "params"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mixinCredentialsJson) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.mixinCredentialsJson.isEmpty {
      try visitor.visitSingularStringField(value: self.mixinCredentialsJson, fieldNumber: 1)
    }
    try { if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MistyswapOfframp_InitiateOfframpRequest, rhs: MistyswapOfframp_InitiateOfframpRequest) -> Bool {
    if lhs.mixinCredentialsJson != rhs.mixinCredentialsJson {return false}
    if lhs._params != rhs._params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MistyswapOfframp_InitiateOfframpResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InitiateOfframpResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "offramp_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.offrampID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.offrampID.isEmpty {
      try visitor.visitSingularBytesField(value: self.offrampID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MistyswapOfframp_InitiateOfframpResponse, rhs: MistyswapOfframp_InitiateOfframpResponse) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.offrampID != rhs.offrampID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MistyswapOfframp_ForgetOfframpRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ForgetOfframpRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "offramp_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.offrampID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.offrampID.isEmpty {
      try visitor.visitSingularBytesField(value: self.offrampID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MistyswapOfframp_ForgetOfframpRequest, rhs: MistyswapOfframp_ForgetOfframpRequest) -> Bool {
    if lhs.offrampID != rhs.offrampID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MistyswapOfframp_ForgetOfframpResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ForgetOfframpResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MistyswapOfframp_ForgetOfframpResponse, rhs: MistyswapOfframp_ForgetOfframpResponse) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MistyswapOfframp_Offramp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Offramp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "params"),
    2: .same(proto: "state"),
    3: .standard(proto: "state_details"),
    4: .standard(proto: "mixin_withdrawal_address_json"),
    5: .standard(proto: "ongoing_swap"),
    6: .standard(proto: "ongoing_withdrawal_json"),
    7: .same(proto: "balances"),
  ]

  fileprivate class _StorageClass {
    var _params: MistyswapOfframp_OfframpParams? = nil
    var _state: MistyswapOfframp_OfframpState = .osInvalid
    var _stateDetails: String = String()
    var _mixinWithdrawalAddressJson: String = String()
    var _ongoingSwap: MistyswapCommon_OngoingSwap? = nil
    var _ongoingWithdrawalJson: String = String()
    var _balances: Dictionary<String,String> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _params = source._params
      _state = source._state
      _stateDetails = source._stateDetails
      _mixinWithdrawalAddressJson = source._mixinWithdrawalAddressJson
      _ongoingSwap = source._ongoingSwap
      _ongoingWithdrawalJson = source._ongoingWithdrawalJson
      _balances = source._balances
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._params) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._stateDetails) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._mixinWithdrawalAddressJson) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._ongoingSwap) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._ongoingWithdrawalJson) }()
        case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._balances) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._params {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if _storage._state != .osInvalid {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 2)
      }
      if !_storage._stateDetails.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stateDetails, fieldNumber: 3)
      }
      if !_storage._mixinWithdrawalAddressJson.isEmpty {
        try visitor.visitSingularStringField(value: _storage._mixinWithdrawalAddressJson, fieldNumber: 4)
      }
      try { if let v = _storage._ongoingSwap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._ongoingWithdrawalJson.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ongoingWithdrawalJson, fieldNumber: 6)
      }
      if !_storage._balances.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._balances, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MistyswapOfframp_Offramp, rhs: MistyswapOfframp_Offramp) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._params != rhs_storage._params {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._stateDetails != rhs_storage._stateDetails {return false}
        if _storage._mixinWithdrawalAddressJson != rhs_storage._mixinWithdrawalAddressJson {return false}
        if _storage._ongoingSwap != rhs_storage._ongoingSwap {return false}
        if _storage._ongoingWithdrawalJson != rhs_storage._ongoingWithdrawalJson {return false}
        if _storage._balances != rhs_storage._balances {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MistyswapOfframp_GetOfframpStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOfframpStatusRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "offramp_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.offrampID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.offrampID.isEmpty {
      try visitor.visitSingularBytesField(value: self.offrampID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MistyswapOfframp_GetOfframpStatusRequest, rhs: MistyswapOfframp_GetOfframpStatusRequest) -> Bool {
    if lhs.offrampID != rhs.offrampID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MistyswapOfframp_GetOfframpStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOfframpStatusResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "offramp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._offramp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._offramp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MistyswapOfframp_GetOfframpStatusResponse, rhs: MistyswapOfframp_GetOfframpStatusResponse) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs._offramp != rhs._offramp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MistyswapOfframp_GetOfframpDebugInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOfframpDebugInfoRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "offramp_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.offrampID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.offrampID.isEmpty {
      try visitor.visitSingularBytesField(value: self.offrampID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MistyswapOfframp_GetOfframpDebugInfoRequest, rhs: MistyswapOfframp_GetOfframpDebugInfoRequest) -> Bool {
    if lhs.offrampID != rhs.offrampID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MistyswapOfframp_GetOfframpDebugInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOfframpDebugInfoResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "debug_info_json"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.debugInfoJson) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.debugInfoJson.isEmpty {
      try visitor.visitSingularStringField(value: self.debugInfoJson, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: MistyswapOfframp_GetOfframpDebugInfoResponse, rhs: MistyswapOfframp_GetOfframpDebugInfoResponse) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.debugInfoJson != rhs.debugInfoJson {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
