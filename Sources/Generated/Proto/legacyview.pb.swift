// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: legacyview.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright (c) 2018-2022 The MobileCoin Foundation

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

//// 
//// *** DISCLAIMER *** 
////
//// This proto is deprecated and no longer used, we're re-importing it so we can re-use serialized data in 
//// some Swift unit tests. Once we convert these tests we should remove this proto.
//// 
//// *** END DISCLAIMER *** 
////
//// The schema for the decrypted TxOutSearchResult ciphertext
//// This is the information that the Ingest enclave produces for the user about their TxOut
////
//// Note: The fields of FogTxOut are flattened here because it reduces the size of the protobuf
//// enough to make a difference for the quality of ORAM implementation, like ~10% better memory utilization
////
//// Note: Fog TxOutRecord DOES NOT include the encrypted fog hint of the original TxOut, because it is big,
//// and the client cannot read it anyways. However, when using the TxOut to build transactions, you must have that
//// or the merkle proofs will fail validation, at least for now.
//// The fog merkle proof server gives you a TxOut with fog hint, as it appears in blockchain,
//// and that's the version of the TxOut that you should use when building a transaction.
public struct FogView_TxOutRecordLegacy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The (compressed ristretto) bytes of commitment associated to amount field in the TxOut that was recovered
  ////
  //// Note: This field is omitted in recent versions, because it can be reconstructed by the recipient instead.
  public var txOutAmountCommitmentData: Data = Data()

  //// The masked value associated to amount field in the TxOut that was recovered
  public var txOutAmountMaskedValue: UInt64 = 0

  //// The (compressed ristretto) bytes of the target key associated to the TxOut that was recovered
  public var txOutTargetKeyData: Data = Data()

  //// The (compressed ristretto) bytes of the public key associated to the TxOut that was recovered
  public var txOutPublicKeyData: Data = Data()

  //// The global index of this TxOut in the set of all TxOuts in the entire block chain
  public var txOutGlobalIndex: UInt64 = 0

  //// The index of the block index in which this TxOut appeared
  public var blockIndex: UInt64 = 0

  //// The timestamp of the block containing this output.
  //// Some blocks, like the origin block, don't have a timestamp, and this value is u64::MAX
  //// Other blocks are expected to have timestamps.
  ////
  //// Note: The timestamp is based on untrusted reporting of time from ONE of the consensus validators.
  //// Because it is a distributed system, it may not be the SAME consensus validator from block to block,
  //// and the timestamps may not make even a minimal amount of sense when the validator differs.
  ////
  //// These timestamps are
  //// - NOISY, forward and backwards in time, depending on system time settings of many different servers.
  //// - NOT MONOTONIC: it's possible that you get a timestamp for block 101 that is before the timestamp for block 100.
  //// - Not even CONSISTENT across fog services: It's possible you get a different timestamp for a TxOut in block 100,
  ////   than you do for a key image in block 100 from the key image endpoint.
  ////   This is unavoidable right now because it is possible that fog-ingest has different levels of
  ////   connectivity from the fog-key-image service to the blockchain data sources.
  ////
  //// Timestamps are BEST-EFFORT and for a good user experience, the client software should attempt to reconcile these
  //// timestamps, so that events that have a happens-before relationship in the system, have timestamps that reflect that.
  //// Otherwise, we should expect users to be confused and disturbed about the occasional time-travelling transaction.
  ////
  //// We hope to improve the quality guarantees of these timestamps over time, but for now this is the best we
  //// can do until some changes can be made to the consensus network and other services related to timestamps.
  ////
  //// Represented as seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z.
  public var timestamp: UInt64 = 0

  //// The crc32 of the commitment data bytes.
  //// This is a 4-byte IEEE crc32 of the bytes of the tx_out_amount_commitment_data bytes, which is present if
  //// the full tx_out_amount_commitment_data is omitted.
  //// The client can recompute the tx_out_amount_commitment from the other data that we include.
  //// They can confirm correct recomputation by checking this crc value.
  public var txOutAmountCommitmentDataCrc32: UInt32 = 0

  //// The bytes of the encrypted memo.
  //// This exactly 66 bytes when present.
  //// This is omitted for TxOut's from before the upgrade that introduced memos.
  public var txOutEMemoData: Data = Data()

  //// The masked token id associated to the amount field in the TxOut that was recovered
  public var txOutAmountMaskedTokenID: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension FogView_TxOutRecordLegacy: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "fog_view"

extension FogView_TxOutRecordLegacy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TxOutRecordLegacy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_out_amount_commitment_data"),
    2: .standard(proto: "tx_out_amount_masked_value"),
    3: .standard(proto: "tx_out_target_key_data"),
    4: .standard(proto: "tx_out_public_key_data"),
    5: .standard(proto: "tx_out_global_index"),
    6: .standard(proto: "block_index"),
    7: .same(proto: "timestamp"),
    8: .standard(proto: "tx_out_amount_commitment_data_crc32"),
    9: .standard(proto: "tx_out_e_memo_data"),
    10: .standard(proto: "tx_out_amount_masked_token_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txOutAmountCommitmentData) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.txOutAmountMaskedValue) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.txOutTargetKeyData) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.txOutPublicKeyData) }()
      case 5: try { try decoder.decodeSingularFixed64Field(value: &self.txOutGlobalIndex) }()
      case 6: try { try decoder.decodeSingularFixed64Field(value: &self.blockIndex) }()
      case 7: try { try decoder.decodeSingularFixed64Field(value: &self.timestamp) }()
      case 8: try { try decoder.decodeSingularFixed32Field(value: &self.txOutAmountCommitmentDataCrc32) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self.txOutEMemoData) }()
      case 10: try { try decoder.decodeSingularBytesField(value: &self.txOutAmountMaskedTokenID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txOutAmountCommitmentData.isEmpty {
      try visitor.visitSingularBytesField(value: self.txOutAmountCommitmentData, fieldNumber: 1)
    }
    if self.txOutAmountMaskedValue != 0 {
      try visitor.visitSingularFixed64Field(value: self.txOutAmountMaskedValue, fieldNumber: 2)
    }
    if !self.txOutTargetKeyData.isEmpty {
      try visitor.visitSingularBytesField(value: self.txOutTargetKeyData, fieldNumber: 3)
    }
    if !self.txOutPublicKeyData.isEmpty {
      try visitor.visitSingularBytesField(value: self.txOutPublicKeyData, fieldNumber: 4)
    }
    if self.txOutGlobalIndex != 0 {
      try visitor.visitSingularFixed64Field(value: self.txOutGlobalIndex, fieldNumber: 5)
    }
    if self.blockIndex != 0 {
      try visitor.visitSingularFixed64Field(value: self.blockIndex, fieldNumber: 6)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularFixed64Field(value: self.timestamp, fieldNumber: 7)
    }
    if self.txOutAmountCommitmentDataCrc32 != 0 {
      try visitor.visitSingularFixed32Field(value: self.txOutAmountCommitmentDataCrc32, fieldNumber: 8)
    }
    if !self.txOutEMemoData.isEmpty {
      try visitor.visitSingularBytesField(value: self.txOutEMemoData, fieldNumber: 9)
    }
    if !self.txOutAmountMaskedTokenID.isEmpty {
      try visitor.visitSingularBytesField(value: self.txOutAmountMaskedTokenID, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FogView_TxOutRecordLegacy, rhs: FogView_TxOutRecordLegacy) -> Bool {
    if lhs.txOutAmountCommitmentData != rhs.txOutAmountCommitmentData {return false}
    if lhs.txOutAmountMaskedValue != rhs.txOutAmountMaskedValue {return false}
    if lhs.txOutTargetKeyData != rhs.txOutTargetKeyData {return false}
    if lhs.txOutPublicKeyData != rhs.txOutPublicKeyData {return false}
    if lhs.txOutGlobalIndex != rhs.txOutGlobalIndex {return false}
    if lhs.blockIndex != rhs.blockIndex {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.txOutAmountCommitmentDataCrc32 != rhs.txOutAmountCommitmentDataCrc32 {return false}
    if lhs.txOutEMemoData != rhs.txOutEMemoData {return false}
    if lhs.txOutAmountMaskedTokenID != rhs.txOutAmountMaskedTokenID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
